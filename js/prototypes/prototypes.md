# Прототипи, функції конструктори, класи

Механізм роботи **прототипів** в JS дозволяє об'єктам успадковувати функціонал (властивості і методи) один одного. На відміну від класничних ООП мов програмування, де подібний результат досягається завдяки классам і успадковуванню класів. Проте, не дивлячись на некласничний спосіб реалізації, ми отримаємо повноцінне "успадкування", що описане в парадигмі ООП.

Кожен об'єкт має **прототип**, лянцюг прототипів може продовжуватися, тобто прототип об'єкту так само може мати свій прототип. Якщо прототип дорівнює null, це означає, що прототипу не існує і те що ланцюг закінчився.

Коли використивується властивість або метод об'єкту, йде перевірка чи вказана властивість/метод є у самого цільового об'єкту. Якщо немає - йде перевірка у **прототипа** цього об'єкту. і так далі по ланцюгу. Як тільки властивість/метод знайдено - пошук зупиняється, таким чином якщо і у цільового об'єкта і у його прототипа є властивість з однаковою назвою - цільовий об'єкт бути мати пріоритет, так як він у ланцюгу перший.

Отримати прототип об'єкту можна використовуючи метод `Object.getPrototypeOf`. Зараз це вважається стандартною і рекомендованою практикою.

    const obj = {}; // Власноруч створений пустий об'єкт
    console.log(obj.toString());
    // В консолі виводиться '[object Object]'
    // Виклик toString не буде помилкою, бо такий метод буде знайдено в прототипі
    console.log(Object.getPrototypeOf(obj).toString()); // Той самий результат

Існує ще старий, наразі нерекомендований спосіб отримати прототип - через властивість `__proto__` у цільового об'єкту.
Історія як з'явилися ці два методи доволі цікава:

- Властивість `prototype` у функцій конструкторів була від самого початку, це найстаріший спосіб створити об'єкт з кастомним прототипом (*далі буде розглянуто детальніше*).
- Далі десь в проміжку між 2009 і 2015 роками з'явився метод `Object.create`. Він дозволяє створити об'єкт з вказаним прототипом. Однак не надає можливості його отримати або змінити. Отже в браузерах імплементували властивість `__proto__` для більш зручної роботи з прототипами, проте ця поведінка не була стандартизованою.
- З виходом ES6 в 2015 році були додані методи `Object.getPrototypeOf` та `Object.setPrototypeOf`, що виконували однакову функцію як з `__proto__`. З цього часу це актуальні і рекомендовані способи взаємодії з прототипами. В той час як `__proto__` досі можна використовувати, він не є стандартом і його підтримка не гарантується, з-за цього і варто уникати його використання.
