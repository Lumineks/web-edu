# Прототипи, функції конструктори, класи

Механізм роботи **прототипів** в JS дозволяє об'єктам успадковувати функціонал (властивості і методи) один одного. На відміну від класичних ООП мов програмування, де подібний результат досягається завдяки класам і успадкуванню класів. Проте, не дивлячись на не класичний спосіб реалізації, ми отримаємо повноцінне "успадкування", що описане в парадигмі ООП.

Кожен об'єкт має **прототип**, лянцюг прототипів може продовжуватися, тобто прототип об'єкту так само може мати свій прототип. Якщо прототип дорівнює null, це означає, що прототипу не існує і те що ланцюг закінчився.

Коли використовується властивість або метод об'єкту, йде перевірка чи вказана властивість/метод є у самого цільового об'єкту. Якщо немає - йде перевірка у **прототипа** цього об'єкту. і так далі по ланцюгу. Як тільки властивість/метод знайдено - пошук зупиняється, таким чином якщо і у цільового об'єкта і у його прототипа є властивість з однаковою назвою - цільовий об'єкт бути мати пріоритет, так як він у ланцюгу перший.

Отримати прототип об'єкту можна використовуючи метод `Object.getPrototypeOf`. Зараз це вважається стандартною і рекомендованою практикою.

    const obj = {}; // Власноруч створений пустий об'єкт
    console.log(obj.toString());
    // В консолі виводиться '[object Object]'
    // Виклик toString не буде помилкою, бо такий метод буде знайдено в прототипі
    console.log(Object.getPrototypeOf(obj).toString()); // Той самий результат

 Існує ще старий, наразі не рекомендований спосіб отримати прототип - через властивість `__proto__` у цільового об'єкту. 
 
Історія як з'явилися ці два методи доволі цікава:
 - Властивість `prototype` у функцій конструкторів була від самого початку, це найстаріший спосіб створити об'єкт з кастомним прототипом (*більш детальніше далі*).
 - Далі десь в проміжку між 2009 і 2015 роками з'явився метод `Object.create`. Він дозволяє створити об'єкт з вказаним прототипом (*більш детальніше далі*). Однак не надає можливості його отримати або змінити. Отже в браузерах імплементували властивість `__proto__` для більш зручної роботи з прототипами, проте ця поведінка не була стандартизованою. 
 - З виходом ES6 в 2015 році були додані методи `Object.getPrototypeOf` та `Object.setPrototypeOf`, що виконували однакову функцію як з `__proto__`. З цього часу це актуальні і рекомендовані способи взаємодії з прототипами. В той час як `__proto__` досі можна використовувати, він не є стандартом і його підтримка не гарантується, з-за цього і варто уникати його використання.

## Створення та зміна прототипів

### Object.create

`Object.create(object)` - створює новий об’єкт, встановлюючи в якості прототипу об’єкт що був переданий першим аргументом. Приклади наводжу окремо (див. коментарі). 




### Приклад проблеми з `__proto__`
Бувають ситуації коли необхідно зберігати пари ключ-значення (далі **dictionary**). Спеціально для такої задачі існує `Map`, проте доволі часто замість нього використовують звичайні об’єкти. Крім того, що `Map` є більш оптимізованим інструментом під цей конкретний сценарій, зі звичайними об’єктами є додаткові нюанси. 

Звичайний об’єкт - `{ }` не є **пустим** dictionary. Якраз з-за механізму прототипів можна стикнутися з неочікуваною поведінкою у разі випадкового збігу або використання властивостей, які вже є у ланцюгу прототипів. 

    const dictionary = {} // Очікується що пар ключ-значення немає
    const key = prompt("Enter the key"); // Вводиться 'toString'
    console.log(Boolean(dictionary[key])); // Мало би бути false, бо dictionary щойно створенний, але буде true - тому що 'toString' було знайдено у прототипа

Саме з-за подібних нюансів все ж таки варто використовувати Map для вирішення таких сценаріїв. Проте звичайні об’єкти також можна "виправити", якщо лишити їх прототипу.

    const dictionary = Object.create(null);
    
Таким чином буде створений дійсно пустий об’єкт.  Варто пам’ятати що в такому випадку не буде доступу до жодних методів - `toString`, `hasOwnProperty` і т.д. І це також доволі просто пропустити і забути в моменті, що так само призведе до різних неочікуваних помилок.
